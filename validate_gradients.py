#!/usr/bin/env python3\n\"\"\"\nGradient Flow Validation - Quick Test\n\nThis script validates that gradients flow correctly through the system:\n1. Initialize all components\n2. Run a forward pass  \n3. Compute gradients\n4. Check gradient properties (finite, reasonable magnitude)\n\nThis is the final validation step for the fixes.\n\"\"\"\n\nimport sys\nimport os\nfrom pathlib import Path\n\n# Add project root to Python path\nproject_root = Path(__file__).parent\nsys.path.insert(0, str(project_root))\n\nimport jax\nimport jax.numpy as jnp\nfrom jax import random, grad\n\n# Configure JAX\njax.config.update(\"jax_enable_x64\", True)\n\ndef test_gradient_flow():\n    \"\"\"Test gradient flow through simplified system components\"\"\"\n    print(\"\ud83e\uddee Testing Gradient Flow...\")\n    \n    try:\n        # Import components\n        from configs.default_config import get_minimal_config\n        from core.physics import create_initial_drone_state, dynamics_step, PhysicsParams\n        from core.perception import (\n            create_default_perception_module, pointcloud_to_graph, \n            DroneState as PerceptionDroneState, GraphConfig\n        )\n        from simple_policy import create_simple_policy_network\n        from core.safety import create_default_safety_layer\n        \n        print(\"\u2705 All imports successful\")\n        \n        # Create configuration and components\n        config = get_minimal_config()\n        key = random.PRNGKey(42)\n        gnn_key, policy_key, test_key = random.split(key, 3)\n        \n        # Initialize physics\n        physics_params = PhysicsParams(\n            dt=config.physics.dt,\n            mass=config.physics.drone.mass,\n            thrust_to_weight=config.physics.drone.thrust_to_weight_ratio,\n            drag_coefficient=config.physics.drone.drag_coefficient\n        )\n        \n        initial_state = create_initial_drone_state(jnp.array([0.0, 0.0, 1.0]))\n        print(f\"\u2705 Physics initialized, initial state: {initial_state.position}\")\n        \n        # Initialize perception\n        gnn_perception = create_default_perception_module()\n        test_pointcloud = random.normal(test_key, (10, 3)) * 2.0\n        \n        graph_config = GraphConfig(k_neighbors=3)\n        graph, node_types = pointcloud_to_graph(\n            PerceptionDroneState(\n                position=initial_state.position,\n                velocity=initial_state.velocity, \n                orientation=jnp.eye(3),\n                angular_velocity=jnp.zeros(3)\n            ),\n            test_pointcloud,\n            graph_config\n        )\n        \n        gnn_params = gnn_perception.cbf_net.init(gnn_key, graph, node_types)\n        print(\"\u2705 Perception initialized\")\n        \n        # Initialize policy\n        policy_network = create_simple_policy_network()\n        policy_input = jnp.concatenate([\n            initial_state.position,  # 3 elements\n            initial_state.velocity,  # 3 elements  \n            jnp.zeros(3)  # 3 placeholder elements\n        ])\n        policy_params = policy_network.init(policy_key, policy_input)\n        print(\"\u2705 Policy initialized\")\n        \n        # Initialize safety layer\n        safety_layer = create_default_safety_layer()\n        print(\"\u2705 Safety layer initialized\")\n        \n        # Test forward pass through all components\n        def system_loss(params_dict):\n            \"\"\"Simple system loss for gradient testing\"\"\"\n            # Extract parameters\n            gnn_p = params_dict['gnn']\n            policy_p = params_dict['policy']\n            \n            # GNN forward pass\n            cbf_value = gnn_perception.cbf_net.apply(gnn_p, graph, node_types)\n            if cbf_value.shape == (1,):\n                cbf_value = cbf_value[0]\n            \n            # Policy forward pass\n            u_nom, _ = policy_network.apply(policy_p, policy_input, None)\n            \n            # Safety filter (simplified)\n            cbf_grad = random.normal(test_key, (3,))  # Mock gradient\n            u_safe, _ = safety_layer.safety_filter(u_nom, cbf_value, cbf_grad, initial_state)\n            \n            # Physics step\n            next_state = dynamics_step(initial_state, u_safe, physics_params)\n            \n            # Loss: distance to target\n            target_pos = jnp.array([1.0, 1.0, 2.0])\n            loss = jnp.sum((next_state.position - target_pos) ** 2)\n            \n            return loss\n        \n        # Bundle parameters\n        all_params = {\n            'gnn': gnn_params,\n            'policy': policy_params\n        }\n        \n        # Test loss computation\n        loss_value = system_loss(all_params)\n        print(f\"\u2705 Forward pass successful, loss: {loss_value:.6f}\")\n        \n        # Test gradient computation\n        gradients = grad(system_loss)(all_params)\n        \n        # Check gradient properties\n        gnn_grad_norm = jnp.sqrt(sum(\n            jnp.sum(g ** 2) for g in jax.tree_util.tree_leaves(gradients['gnn'])\n        ))\n        \n        policy_grad_norm = jnp.sqrt(sum(\n            jnp.sum(g ** 2) for g in jax.tree_util.tree_leaves(gradients['policy'])\n        ))\n        \n        print(f\"\u2705 Gradient computation successful\")\n        print(f\"   GNN gradient norm: {gnn_grad_norm:.6f}\")\n        print(f\"   Policy gradient norm: {policy_grad_norm:.6f}\")\n        \n        # Validate gradient properties\n        assert jnp.isfinite(gnn_grad_norm), \"GNN gradients must be finite\"\n        assert jnp.isfinite(policy_grad_norm), \"Policy gradients must be finite\"\n        assert gnn_grad_norm > 1e-8, f\"GNN gradients should be meaningful, got {gnn_grad_norm}\"\n        assert policy_grad_norm > 1e-8, f\"Policy gradients should be meaningful, got {policy_grad_norm}\"\n        assert gnn_grad_norm < 1e3, f\"GNN gradients should be reasonable, got {gnn_grad_norm}\"\n        assert policy_grad_norm < 1e3, f\"Policy gradients should be reasonable, got {policy_grad_norm}\"\n        \n        print(\"\u2705 Gradient validation: ALL CHECKS PASSED\")\n        print(f\"   \u2713 Gradients are finite\")\n        print(f\"   \u2713 Gradients are meaningful (> 1e-8)\")\n        print(f\"   \u2713 Gradients are reasonable (< 1e3)\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"\u274c Gradient flow test failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n\ndef main():\n    \"\"\"Main validation routine\"\"\"\n    print(\"\ud83d\ude80 GRADIENT FLOW VALIDATION\")\n    print(\"=\" * 50)\n    print(\"Testing end-to-end gradient computation through:\")\n    print(\"  1. GNN Perception (CBF computation)\")\n    print(\"  2. Policy Network (control generation)\")\n    print(\"  3. Safety Layer (control filtering)\")\n    print(\"  4. Physics Engine (state evolution)\") \n    print(\"=\" * 50)\n    print()\n    \n    success = test_gradient_flow()\n    \n    print()\n    print(\"=\" * 50)\n    if success:\n        print(\"\ud83c\udf89 GRADIENT FLOW VALIDATION: PASSED!\")\n        print()\n        print(\"\u2705 Key Achievements:\")\n        print(\"   \u2022 End-to-end gradient computation works\")\n        print(\"   \u2022 All gradients are finite and meaningful\")\n        print(\"   \u2022 System is ready for training\")\n        print()\n        print(\"\ud83d\ude80 SYSTEM VALIDATION COMPLETE!\")\n    else:\n        print(\"\u274c GRADIENT FLOW VALIDATION: FAILED\")\n        print(\"System requires additional fixes before training.\")\n    \n    print(\"=\" * 50)\n    return success\n\nif __name__ == \"__main__\":\n    success = main()\n    exit(0 if success else 1)